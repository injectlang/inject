package main

import (
	"encoding/base64"
	"fmt"
	"os"

	"github.com/injectlang/injector"
	_ "github.com/injectlang/injector/log"
	"github.com/rs/zerolog/log"
)

func usage() {
	fmt.Fprintf(os.Stderr, "usage: %s '<string_to_encrypt>' '<public_json_keyset>'\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Encrypt a string using a public key.  This uses Google Tink's \"exchange\" method,\n")
	fmt.Fprintf(os.Stderr, "which is HPKE (Hybrid Public Key Encryption).  See RFC 9180 for more info on HPKE.\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "To use this program, you'll need a public/private keypair generated by Tink.\n")
	fmt.Fprintf(os.Stderr, "Install the program tinkey, then run:\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "tinkey create-keyset --key-template=DHKEM_X25519_HKDF_SHA256_HKDF_SHA256_AES_256_GCM --out private_keyset.json\n")
	fmt.Fprintf(os.Stderr, "tinkey create-public-keyset --in private_keyset.json --out public_keyset.json\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "For more info, see https://developers.google.com/tink/exchange-data\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "example:\n")
	fmt.Fprintf(os.Stderr, "%s \"Hello World\" \"$(cat public_keyset.json)\"\n", os.Args[0])
	fmt.Fprintf(os.Stderr, " or\n")
	fmt.Fprintf(os.Stderr, "%s \"Hello World\" '{\"primaryKeyId\":6138445,\"key\":[{\"keyData\":{\"typeUrl\":\"type.googleapis.com/google.crypto.tink.HpkePublicKey\",\"value\":\"EgYIARABGAIaIJO9jY9uaVIcwcl4EuKYjRaCJIsVKdGoC6akdYTP1VxK\",\"keyMaterialType\":\"ASYMMETRIC_PUBLIC\"},\"status\":\"ENABLED\",\"keyId\":6138445,\"outputPrefixType\":\"TINK\"}]}'\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "would output an encrypted string like (your output will be different, but you can still decrypt the example below):\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "AQBdqk3v3MinOx72ZUTmRLsMn3KlmU2UUmy+eyzrR03Y4397IExQbNyGzisR0uOoS87CNcH9A1pwfmf/R2fVpQ==\n\n")
	os.Exit(1)
}

func main() {
	if len(os.Args) != 3 {
		usage()
	}

	strToEncrypt := os.Args[1]
	publicJsonKeyset := os.Args[2]
	e := injector.NewEncryptor(publicJsonKeyset)

	encryptionContext := []byte(nil)
	ciphertext, err := e.Encrypt([]byte(strToEncrypt), encryptionContext)
	if err != nil {
		log.Fatal().Msgf("could not encrypt: %s", err)
	}
	b64ciphertext := base64.StdEncoding.EncodeToString(ciphertext)
	fmt.Printf("%s", b64ciphertext)
}
